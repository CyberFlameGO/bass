(provide [start]
  (def bass-start start)

  (defn start [thunk name sha repo inst-id app-id key]
    (let [check-run (create name sha repo inst-id app-id key
                            :status "in_progress"
                            :started-at (now 0))]
      (log "created check run" :repo repo :name name :sha sha :run check-run:id)
      (bass-start thunk
        (fn [ok?]
          (update check-run:id repo inst-id app-id key
                  :status "completed"
                  :conclusion (if ok? "success" "failure")
                  :completed-at (now 0))))))

  (def gh-app
    (-> ($ go build -o ../gh-app ./)
        (with-env {:CGO_ENABLED "0"})
        (with-mount *dir*/gh-app/ ./src/)
        (with-dir ./src/)
        (with-image (linux/golang))
        (subpath ./gh-app)))

  (defn gh-api [method path payload inst-id app-id key]
    (-> ($ $gh-app -a (str app-id) -i (str inst-id) -p /private-key
           -X $method $path)
        (with-stdin [payload])
        (with-image (linux/alpine))
        (with-mount key /private-key)
        (read :json)
        next))

  (defn create [name sha repo inst-id app-id key & kwargs]
    (let [payload (assoc {:name name :head-sha sha} & kwargs)]
      (log "creating check" :repo repo :name name :sha sha)
      (gh-api "POST" (str "repos/" repo "/check-runs") payload
              inst-id app-id key)))

  (defn update [run-id repo inst-id app-id key & kwargs]
    (let [payload (list->scope kwargs)]
      (log "updating check" :run run-id :payload payload)
      (gh-api "PATCH" (str "repos/" repo "/check-runs/" run-id) payload
              inst-id app-id key))))
