(def *core-types*
  {:registry-image "concourse/registry-image-resource"
   :docker-image "concourse/docker-image-resource"
   :git "concourse/git-resource"
   :time "concourse/time-resource"})

(def *config*
  (next *stdin*
        {:platforms {:linux linux}
         :types *core-types*}))

(provide (resource get-latest run-task)
  (defn resource [platform type source]
    (def image
      (if (keyword? type)
        (-> *config* :types type)
        type))

    (defn check [version]
      (-> (/opt/resource/check {:source source :version version})
          (on-platform platform)
          (in-image image)))

    (defn get [version params]
      (-> (/opt/resource/in {:source source :version version :params params})
          (with-args ./)
          (on-platform platform)
          (in-image image)))

    (defn put [params]
      (-> (/opt/resource/out {:source source :params params})
          (with-args ./)
          (on-platform platform)
          (in-image image)))

    ; TODO: alternatively, define an env and return it
    (fn cmdline
      (case cmdline
        [.check]
        (apply stream (next (run (check null))))

        [.check version]
        (apply stream (next (run (check version))))

        [.get version & params]
        (path (get version (list->object params)) ./)

        [.get-metadata version & params]
        (:metadata (next (run (get version (list->object params)))))

        [.put & params]
        (next (run (put version (list->object params)))))))

  (defn get-latest [r & kwargs]
    (r .get (last (r .check)) & kwargs))

  (defn run-task [config & kwargs]
    (let [opts (list->object kwargs)
          workload (task->workload config opts)

          output-configs (:outputs config [])
          output-pairs (map (fn [output]
                              (let [name (:name output)
                                    src (:path output name)]
                                [(string->keyword name)
                                 (path workload (string->dir src))]))
                            output-configs)]
      {:outputs (list->object (apply append output-pairs))
       :result (run workload)}))

  (defn task->workload [config opts]
    (let [platform-name (string->keyword (-> config :platform))
          platform (-> *concourse-config* :platforms platform-name)

          image-type-name (string->keyword (-> config :image-resource :type))
          image-type (-> *concourse-config* :types image-type-name)
          image-source (-> config :image-resource :source)
          image-params (-> config :image-resource (:params {}) object->list)
          image-version (-> config :image-resource (:version null))
          image-resource (resource platform image-type image-source)
          image (if image-version
                  (get-image-resource image-resource version & image-params)
                  (get-latest-image-resource image-resource & image-params))

          path (string->path (-> config :run :path))
          args (-> config :run (:args []))
          dir (string->dir (-> config :run (:dir ".")))

          privileged (:privileged opts false)

          provided-inputs (:inputs opts {})
          configured-inputs (:inputs config)
          mounts (filter id (map (fn [i] (input-mount provided-inputs i))
                                 configured-inputs))

          ; TODO: convert nil values to empty strings
          configured-params (:params config {})
          provided-params (:params opts {})
          env (reduce-kv (fn [r k v] (assoc r k (if (null? v) "" v)))
                         {}
                         (merge configured-params provided-params))]
      (-> (path)
          (with-args & args)
          (in-dir dir)
          (with-mounts mounts)
          (with-env env)
          (on-platform platform)
          (in-image image)
          (with-insecure privileged))))

  (defn image-resource [resource]
    (let [fetched (get-latest resource :format "oci")]
      fetched/image.tar))

  (defn get-latest-image-resource [resource & params]
    (let [got (get-latest resource :format "oci" & params)]
      got/image.tar))

  (defn get-image-resource [resource version & kwargs]
    (let [got (resource .get version :format "oci" & params)]
      got/image.tar))

  (defn input-mount [inputs input]
    (let [name (:name input)
          input-name (string->keyword name)
          source (input-name inputs)]
      (if source
        {:source source
         :target (-> input (:path name) string->dir)}
        null))))
