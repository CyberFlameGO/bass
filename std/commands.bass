(provide [$]
  (defn reduce [f xs a]
    (if (empty? xs)
      a
      (reduce f (rest xs) (f a (first xs)))))

  (defn append xss
    (defn append2 [xs ys]
      (if (empty? xs)
        ys
        (cons (first xs) (append2 (rest xs) ys))))

    (reduce append2 xss ()))

  (defn append-assoc [acc kw vals]
    (assoc acc kw (append (kw acc []) vals)))

  (defn resolve-arg [a env]
    (let [word (symbol->string a)
          start (substring word 0 1)]
      (if (= start "$")
        (eval (string->symbol (substring word 1)) env)
        word)))

  (defn build-workload [acc args env]
    (cond
      (empty? args)
        (object->list acc)

      (pair? args)
        (let [(a . as) args]
          (cond
            (keyword? a)
              (build-workload
                (assoc acc a (eval (first as) env))
                (rest as)
                env)

            (symbol? a)
              (build-workload
                (append-assoc acc :args [(resolve-arg a env)])
                as
                env)

            :else
              (build-workload
                (append-assoc acc :args [(eval a env)])
                as
                env)))

        ; . notation; append its value to the end
        :else
          (build-workload
            (append-assoc acc :args (eval args env))
            []
            env)))

  ; creates a workload to run a command with args
  ;
  ; Takes a path followed by a list of args, which must be string? or path?.
  ;
  ; Returns a workload that will execute the path with the args passed on the
  ; commandline.
  ;
  ; This function is named to mimic a traditional terminal prompt.
  (defop $ [path . args] env
    (let [kwargs (build-workload {} args env)]
      (apply path kwargs env))))
