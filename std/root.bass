; This module bootstraps the ground environment with basic language facilities.
_

; evaluate a sequence, returning the last value
(def do
  ((wrap
     (op (do2) _
       (do2
         (def aux
           (op (head . tail) env
             (if (empty? tail)
               (eval head env)
               (do2
                 (eval head env)
                 (eval (cons aux tail) env)))))
         (op body env
           (if (empty? body)
             null
             (eval (cons aux body) env))))))
   (op (first second) env
     ((wrap (op _ _ (eval second env)))
      (eval first env)))))

; construct a list from a sequence of values
(def list (wrap (op x _ x)))

; prepend a sequence of values to a list given as the final argument
(def list*
  (wrap
    (op args _
      (do
        (def aux
          (wrap
            (op ((head . tail)) _
              (if (empty? tail)
                head
                (cons head (aux tail))))))
        (aux args)))))

; return the first value in a pair
;
; Typically the head of a linked list.
(def first (wrap (op ((f . _)) _ f)))

; return the second value in a pair
;
; Typically the tail of a linked list.
(def rest (wrap (op ((_ . r)) _ r)))

; return the length of the given list
(def length
  (wrap
    (op (x) _
        (if (empty? x)
          0
          (+ 1 (length (rest x)))))))

; construct an operative
;
; An operative is a combiner that is called with unevaluated arguments and the
; caller's dynamic environment.
;
; Operatives are used to define new syntactic constructs.
(def op
  ((wrap
     (op (op) _
         (op (formals eformal . body) env
           (eval [op formals eformal
                  (if (> (length body) 1)
                    (cons do body)
                    (first body))]
                 env))))
   op))

; construct an operative and bind it to a symbol
;
; Returns the bound symbol. Write a comment before (defop) to provide
; documentation.
(def defop
  (op (name formals eformal . body) env
    (eval [def name [op formals eformal . body]] env)))

; construct a function
;
; Functions are applicative combiners which evaluate their arguments before
; passing them to an underlying operative.
(defop fn (formals . body) env
  (wrap (eval [op formals _ . body] env)))

; construct a function and bind it to a symbol
;
; Returns the bound symbol. Write a comment before (defn) to provide
; documentation.
(defop defn (name formals . body) env
  (eval [def name [fn formals . body]] env))

; return the second member of a linked list
(defn second [(_ x . _)]   x)

; return third member of a linked list
(defn third  [(_ _ x . _)] x)

; return the current environment
(defop get-current-env _ e e)

; returns the unevaluated form
(defop quote [x] _ x)

; returns a list containing the result of applying f to each member of xs
(def map
  (fn (f xs)
    (if (empty? xs)
      ()
      (cons (f (first xs))
            (map f (rest xs))))))

; calls a function with alternating pairs in a flat list (i.e. with pairs ungrouped)
;
; Takes 2-arity function and a flat pair sequence. Walks the sequence and calls
; f with 2 values at a time.
;
; Raises an error if the list has uneven length.
(defn map-pairs [f ps]
  (defn map-pairs-acc [f a ps]
    (if (empty? ps)
      (if (null? a)
        []
        uneven-pairs) ; TODO: proper error
      (if (null? a)
        (map-pairs-acc f (first ps) (rest ps))
        (cons (f a (first ps))
              (map-pairs-acc f null (rest ps))))))

  (map-pairs-acc f null ps))

; binds values in a child environment
;
; Takes a flat pair sequence alternating bindings and their values. Binds
; and evaluates each value in sequence, allowing later bindings to refer to
; earlier bindings.
;
; Returns the result of evaluating the body in the child environment.
(defop let (bindings . body) env
  (def child (make-env env))

  (map-pairs
    (fn [binding val]
      (eval [def binding val] child))
    bindings)

  (eval [do . body] child))

; provide bindings to the current scope from a nested scope
;
; Allows for modularity in code, selectively providing bindings while
; encapsulating bindings that they use.
(def provide
  (op [symbols . body] env
    (let [inner (make-env env)]
      (eval [do . body] inner)
      (map
        (fn [sym]
          (let [val (eval sym inner)
                com (eval [commentary sym] inner)]
            (eval [comment [def sym (eval sym inner)] com] env)
            sym))
        symbols))))

(provide [cond]
  (defn cond-pairs [f a ps]
    (if (empty? ps)
      (if (null? a)
        null
        uneven-pairs) ; TODO: proper error
      (if (null? a)
        (cond-pairs f (first ps) (rest ps))
        (do
          (def (ok . res) (f a (first ps)))
          (if ok
            res
            (cond-pairs f null (rest ps)))))))

  ; if-then-else with many clauses
  ;
  ; Takes a flat pair sequence alternating tests to evaluate and an
  ; expression to evaluate if the test returns a truthy value.
  ;
  ; Returns the result of the evaluated branch, or null if no tests were true.
  ;
  ; By convention, :else is used as the final catch-all test, though any
  ; truthy value works.
  (defop cond clauses env
    (cond-pairs
      (fn [test body]
        (if (eval test env)
          (cons true (eval body env))
          (cons false null)))
      null
      clauses)))
